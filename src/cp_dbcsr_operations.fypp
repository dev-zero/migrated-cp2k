!--------------------------------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations                              !
!   Copyright (C) 2000 - 2016  CP2K developers group                                               !
!--------------------------------------------------------------------------------------------------!

! **************************************************************************************************
!> \brief   DBCSR operations in CP2K
!> \author  Urban Borstnik
!> \date    2009-05-12
!> \version 0.8
!>
!> <b>Modification history:</b>
!> - Created 2009-05-12
! **************************************************************************************************
MODULE cp_dbcsr_operations
   USE cp_blacs_env,                    ONLY: cp_blacs_env_type,&
                                              get_blacs_info
   USE cp_cfm_types,                    ONLY: cp_cfm_type
   USE cp_dbcsr_interface,              ONLY: &
        convert_sizes_to_offsets, cp_create_bl_distribution, cp_dbcsr_add, &
        cp_dbcsr_col_block_sizes, cp_dbcsr_complete_redistribute, cp_dbcsr_copy, cp_dbcsr_create, &
        cp_dbcsr_desymmetrize, cp_dbcsr_distribution, cp_dbcsr_distribution_new, &
        cp_dbcsr_get_data_type, cp_dbcsr_get_info, cp_dbcsr_get_matrix_type, cp_dbcsr_init, &
        cp_dbcsr_iterator, cp_dbcsr_iterator_blocks_left, cp_dbcsr_iterator_next_block, &
        cp_dbcsr_iterator_start, cp_dbcsr_iterator_stop, cp_dbcsr_mp_new, cp_dbcsr_mp_release, &
        cp_dbcsr_multiply, cp_dbcsr_name, cp_dbcsr_norm, cp_dbcsr_release, &
        cp_dbcsr_reserve_all_blocks, cp_dbcsr_row_block_sizes, cp_dbcsr_scale, cp_dbcsr_type, &
        cp_dbcsr_valid_index, cp_dbcsr_verify_matrix, dbcsr_create_dist_block_cyclic, &
        dbcsr_create_dist_r_unrot, dbcsr_distribution_col_clusters, dbcsr_distribution_col_dist, &
        dbcsr_distribution_mp, dbcsr_distribution_obj, dbcsr_distribution_release, &
        dbcsr_distribution_row_clusters, dbcsr_distribution_row_dist, dbcsr_mp_hold, &
        dbcsr_mp_npcols, dbcsr_mp_nprows, dbcsr_mp_obj, dbcsr_norm_frobenius, &
        dbcsr_type_antisymmetric, dbcsr_type_complex_8, dbcsr_type_no_symmetry, dbcsr_type_real_8, &
        dbcsr_type_symmetric
   USE cp_fm_basic_linalg,              ONLY: cp_fm_gemm
   USE cp_fm_struct,                    ONLY: cp_fm_struct_create,&
                                              cp_fm_struct_release,&
                                              cp_fm_struct_type
   USE cp_fm_types,                     ONLY: cp_fm_create,&
                                              cp_fm_get_info,&
                                              cp_fm_release,&
                                              cp_fm_to_fm,&
                                              cp_fm_type
   USE cp_para_types,                   ONLY: cp_para_env_type
   USE distribution_2d_types,           ONLY: distribution_2d_get,&
                                              distribution_2d_type
   USE kinds,                           ONLY: dp

!$ USE OMP_LIB, ONLY: omp_get_max_threads, omp_get_thread_num, omp_get_num_threads
#include "base/base_uses.f90"

   IMPLICIT NONE

   CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'cp_dbcsr_operations'

   PUBLIC :: cp_dbcsr_multiply_local

   ! CP2K API emulation
   PUBLIC :: copy_fm_to_dbcsr, copy_dbcsr_to_fm, &
             copy_dbcsr_to_cfm, copy_cfm_to_dbcsr, &
             cp_dbcsr_sm_fm_multiply, cp_dbcsr_plus_fm_fm_t, &
             copy_dbcsr_to_fm_bc, copy_fm_to_dbcsr_bc, cp_fm_to_dbcsr_row_template, &
             cp_dbcsr_m_by_n_from_template, cp_dbcsr_m_by_n_from_row_template

   ! distribution_2d_type compatibility
   PUBLIC :: cp_dbcsr_dist2d_to_dist

   PUBLIC :: cp_dbcsr_copy_columns_hack

   PRIVATE

CONTAINS



#:for fm, type, constr in [("fm", "REAL", "REAL"), ("cfm", "COMPLEX", "CMPLX")]

! **************************************************************************************************
!> \brief   Copy a BLACS matrix to a dbcsr matrix.
!>
!>          real_matrix=beta*real_matrix+alpha*fm
!>          beta defaults to 0, alpha to 1
!> \param[in] fm              full matrix
!> \param[out] matrix         DBCSR matrix
!> \param[in] keep_sparsity   (optional) retains the sparsity of the input
!>                            matrix
!> \date    2009-10-13
!> \par History
!>          2009-10-13 rewritten based on copy_dbcsr_to_fm
!> \author  Urban Borstnik
!> \version 2.0
! **************************************************************************************************
   SUBROUTINE copy_${fm}$_to_dbcsr(fm, matrix, keep_sparsity)
      TYPE(cp_${fm}$_type), POINTER                      :: fm
      TYPE(cp_dbcsr_type), INTENT(INOUT)                 :: matrix
      LOGICAL, INTENT(IN), OPTIONAL                      :: keep_sparsity

      CHARACTER(LEN=*), PARAMETER :: routineN = 'copy_${fm}$_to_dbcsr'

      TYPE(cp_dbcsr_type)                                :: bc_mat
      INTEGER                                            :: handle

      CALL timeset(routineN, handle)

      CALL copy_${fm}$_to_dbcsr_bc(fm, bc_mat)
      CALL cp_dbcsr_complete_redistribute(bc_mat, matrix, keep_sparsity=keep_sparsity)
      CALL cp_dbcsr_release(bc_mat)

      CALL timestop(handle)
   END SUBROUTINE copy_${fm}$_to_dbcsr


! **************************************************************************************************
!> \brief   Copy a BLACS matrix to a dbcsr matrix with a special block-cyclic distribution,
!>           which requires no complete redistribution.
!> \param fm ...
!> \param bc_mat ...
!> \param beta ...
! **************************************************************************************************
   SUBROUTINE copy_${fm}$_to_dbcsr_bc(fm, bc_mat)
      TYPE(cp_${fm}$_type), POINTER                      :: fm
      TYPE(cp_dbcsr_type)                                :: bc_mat

      CHARACTER(LEN=*), PARAMETER :: routineN = 'copy_${fm}$_to_dbcsr_bc'

      INTEGER :: col, group, handle, mypcol, myproc, myprow, &
                 ncol_block, ncol_global, nrow_block, nrow_global, numproc, row
      INTEGER, ALLOCATABLE, DIMENSION(:)                 :: first_col, first_row, last_col, last_row
      INTEGER, DIMENSION(:), POINTER                     :: col_blk_size, row_blk_size
      INTEGER, DIMENSION(:, :), POINTER                  :: pgrid
      ${type}$(KIND=dp), DIMENSION(:, :), POINTER        :: fm_block, dbcsr_block
      TYPE(cp_blacs_env_type), POINTER                   :: context
      TYPE(dbcsr_distribution_obj)                       :: bc_dist
      TYPE(dbcsr_mp_obj)                                 :: mp_env
      TYPE(cp_dbcsr_iterator)                            :: iter

      CALL timeset(routineN, handle)

#:if(type=="REAL")
      IF (fm%use_sp) CPABORT("copy_${fm}$_to_dbcsr_bc: single precision not supported")
#:endif

      ! Create processor grid
      context => fm%matrix_struct%context
      pgrid => context%blacs2mpi
      group = fm%matrix_struct%para_env%group
      myproc = fm%matrix_struct%para_env%mepos
      numproc = fm%matrix_struct%para_env%num_pe
      myprow = context%mepos(1)
      mypcol = context%mepos(2)
      CALL cp_dbcsr_mp_new(mp_env, pgrid, group, myproc, numproc, myprow, mypcol)

      ! Create a block-cyclic distribution compatible with the FM matrix.
      nrow_block = fm%matrix_struct%nrow_block
      ncol_block = fm%matrix_struct%ncol_block
      nrow_global = fm%matrix_struct%nrow_global
      ncol_global = fm%matrix_struct%ncol_global
      NULLIFY (col_blk_size, row_blk_size)
      CALL dbcsr_create_dist_block_cyclic(bc_dist, &
                                          nrows=nrow_global, ncolumns=ncol_global, & ! Actual full matrix size
                                          nrow_block=nrow_block, ncol_block=ncol_block, & ! BLACS parameters
                                          mp_env=mp_env, &
                                          row_blk_sizes=row_blk_size, col_blk_sizes=col_blk_size) ! block-cyclic row/col sizes
      CALL cp_dbcsr_mp_release(mp_env)

      ! Create the block-cyclic DBCSR matrix
      CALL cp_dbcsr_init(bc_mat)
      CALL cp_dbcsr_create(bc_mat, "Block-cyclic ", bc_dist, &
                           dbcsr_type_no_symmetry, row_blk_size, col_blk_size, nze=0, &
                           reuse_arrays=.TRUE., data_type=dbcsr_type_${type.lower()}$_8)
      CALL dbcsr_distribution_release(bc_dist)

      ! allocate all blocks
      CALL cp_dbcsr_reserve_all_blocks(bc_mat)

      CALL calculate_fm_block_ranges(bc_mat, first_row, last_row, first_col, last_col)

      ! Copy the FM data to the block-cyclic DBCSR matrix.  This step
      ! could be skipped with appropriate DBCSR index manipulation.
      fm_block => fm%local_data
!$OMP PARALLEL DEFAULT(NONE) PRIVATE(iter, row, col, dbcsr_block) &
!$OMP SHARED(bc_mat, last_row, first_row, last_col, first_col, fm_block)
       CALL cp_dbcsr_iterator_start(iter, bc_mat)
       DO WHILE (cp_dbcsr_iterator_blocks_left(iter))
          CALL cp_dbcsr_iterator_next_block(iter, row, col, dbcsr_block)
          dbcsr_block(:, :) = fm_block(first_row(row):last_row(row), first_col(col):last_col(col))
       ENDDO
       CALL cp_dbcsr_iterator_stop(iter)
!$OMP END PARALLEL

      CALL timestop(handle)
   END SUBROUTINE copy_${fm}$_to_dbcsr_bc


! **************************************************************************************************
!> \brief Copy a DBCSR matrix to a BLACS matrix
!> \param[in] matrix          DBCSR matrix
!> \param[out] fm             full matrix
! **************************************************************************************************
   SUBROUTINE copy_dbcsr_to_${fm}$(matrix, fm)
      TYPE(cp_dbcsr_type), INTENT(IN)                    :: matrix
      TYPE(cp_${fm}$_type), POINTER                      :: fm

      CHARACTER(LEN=*), PARAMETER :: routineN = 'copy_dbcsr_to_${fm}$'
      LOGICAL, PARAMETER                                 :: dbg = .FALSE.

      INTEGER, DIMENSION(:), POINTER                     :: col_blk_size, row_blk_size
      INTEGER :: handle, ncol_block, nfullcols_total, &
         nfullrows_total, nrow_block
      TYPE(cp_dbcsr_type)                                :: bc_mat, matrix_nosym
      TYPE(dbcsr_distribution_obj)                       :: bc_dist

      CALL timeset(routineN, handle)

      ! check compatibility
      CALL cp_dbcsr_get_info(matrix, nfullrows_total=nfullrows_total, nfullcols_total=nfullcols_total)
      CPASSERT(fm%matrix_struct%nrow_global==nfullrows_total)
      CPASSERT(fm%matrix_struct%ncol_global==nfullcols_total)

      ! info about the full matrix
      nrow_block = fm%matrix_struct%nrow_block
      ncol_block = fm%matrix_struct%ncol_block

      ! Convert DBCSR to a block-cyclic
      NULLIFY (col_blk_size, row_blk_size)
      CALL dbcsr_create_dist_block_cyclic(bc_dist, &
                                          nfullrows_total, nfullcols_total, &
                                          nrow_block, ncol_block, &
                                          dbcsr_distribution_mp(cp_dbcsr_distribution(matrix)), &
                                          row_blk_size, col_blk_size)

      CALL cp_dbcsr_init(bc_mat)
      CALL cp_dbcsr_create(bc_mat, "Block-cyclic"//cp_dbcsr_name(matrix), bc_dist, &
                           dbcsr_type_no_symmetry, row_blk_size, col_blk_size, &
                           nze=0, data_type=cp_dbcsr_get_data_type(matrix), &
                           reuse_arrays=.TRUE.)
      CALL dbcsr_distribution_release(bc_dist)

      CALL cp_dbcsr_init(matrix_nosym)
      CALL cp_dbcsr_create(matrix_nosym, template=matrix, matrix_type="N")
      CALL cp_dbcsr_desymmetrize(matrix, matrix_nosym)
      CALL cp_dbcsr_complete_redistribute(matrix_nosym, bc_mat)
      CALL cp_dbcsr_release(matrix_nosym)

      CALL copy_dbcsr_to_${fm}$_bc(bc_mat, fm)

      CALL cp_dbcsr_release(bc_mat)

      CALL timestop(handle)
   END SUBROUTINE copy_dbcsr_to_${fm}$


! **************************************************************************************************
!> \brief Copy a DBCSR_BLACS matrix to a BLACS matrix
!> \param bc_mat DBCSR matrix
!> \param[out] fm             full matrix
! **************************************************************************************************
   SUBROUTINE copy_dbcsr_to_${fm}$_bc(bc_mat, fm)
      TYPE(cp_dbcsr_type), INTENT(IN)                    :: bc_mat
      TYPE(cp_${fm}$_type), POINTER                      :: fm

      CHARACTER(LEN=*), PARAMETER :: routineN = 'copy_dbcsr_to_${fm}$_bc'

      INTEGER :: col, handle, row
      INTEGER, ALLOCATABLE, DIMENSION(:)                 :: first_col, first_row, last_col, last_row
      ${type}$(KIND=dp), DIMENSION(:, :), POINTER        :: dbcsr_block, fm_block
      TYPE(cp_dbcsr_iterator)                            :: iter

      CALL timeset(routineN, handle)

#:if(type=="REAL")
      IF (fm%use_sp) CPABORT("copy_dbcsr_to_${fm}$_bc: single precision not supported")
#:endif

      CALL calculate_fm_block_ranges(bc_mat, first_row, last_row, first_col, last_col)

      ! Now copy data to the FM matrix
      fm_block => fm%local_data
      fm_block = ${constr}$(0.0, KIND=dp)
!$OMP PARALLEL DEFAULT(NONE) PRIVATE(iter, row, col, dbcsr_block) &
!$OMP SHARED(bc_mat, last_row, first_row, last_col, first_col, fm_block)
      CALL cp_dbcsr_iterator_start(iter, bc_mat)
      DO WHILE (cp_dbcsr_iterator_blocks_left(iter))
         CALL cp_dbcsr_iterator_next_block(iter, row, col, dbcsr_block)
         fm_block(first_row(row):last_row(row), first_col(col):last_col(col)) = dbcsr_block(:, :)
      ENDDO
      CALL cp_dbcsr_iterator_stop(iter)
!$OMP END PARALLEL

      CALL timestop(handle)
   END SUBROUTINE copy_dbcsr_to_${fm}$_bc

#:endfor

! **************************************************************************************************
!> \brief Helper routine used to copy blocks from DBCSR into FM matrices and vice versa
!> \author Ole Schuett
! **************************************************************************************************
   SUBROUTINE calculate_fm_block_ranges(bc_mat, first_row, last_row, first_col, last_col)
      TYPE(cp_dbcsr_type), INTENT(IN)                    :: bc_mat
      INTEGER :: col, nblkcols_local, nblkcols_total, nblkrows_local, nblkrows_total, row
      INTEGER, ALLOCATABLE, DIMENSION(:)                 :: first_col, first_row, last_col, &
                                                            last_row, local_col_sizes, &
                                                            local_row_sizes
      INTEGER, DIMENSION(:), POINTER                     :: col_blk_size, local_cols, local_rows, &
                                                            row_blk_size

      CALL cp_dbcsr_get_info(bc_mat, &
                             nblkrows_total=nblkrows_total, &
                             nblkcols_total=nblkcols_total, &
                             nblkrows_local=nblkrows_local, &
                             nblkcols_local=nblkcols_local, &
                             local_rows=local_rows, &
                             local_cols=local_cols, &
                             row_blk_size=row_blk_size, &
                             col_blk_size=col_blk_size )

      ! calculate first_row and last_row
      ALLOCATE (local_row_sizes(nblkrows_total))
      local_row_sizes(:) = 0
      IF (nblkrows_local .GE. 1) THEN
         DO row = 1, nblkrows_local
            local_row_sizes(local_rows(row)) = row_blk_size(local_rows(row))
         END DO
      ENDIF
      ALLOCATE (first_row(nblkrows_total), last_row(nblkrows_total))
      CALL convert_sizes_to_offsets(local_row_sizes, first_row, last_row)

      ! calculate first_col and last_col
      ALLOCATE (local_col_sizes(nblkcols_total))
      local_col_sizes(:) = 0
      IF (nblkcols_local .GE. 1) THEN
         DO col = 1, nblkcols_local
            local_col_sizes(local_cols(col)) = col_blk_size(local_cols(col))
         END DO
      ENDIF
      ALLOCATE (first_col(nblkcols_total), last_col(nblkcols_total))
      CALL convert_sizes_to_offsets(local_col_sizes, first_col, last_col)

  END SUBROUTINE calculate_fm_block_ranges


! **************************************************************************************************
!> \brief hack for dbcsr_copy_columns
!> \param matrix_b ...
!> \param matrix_a ...
!> \param ncol ...
!> \param source_start ...
!> \param target_start ...
!> \param para_env ...
!> \param blacs_env ...
!> \author vw
! **************************************************************************************************
   SUBROUTINE cp_dbcsr_copy_columns_hack(matrix_b, matrix_a, &
                                         ncol, source_start, target_start, para_env, blacs_env)

      TYPE(cp_dbcsr_type), INTENT(INOUT)                 :: matrix_b
      TYPE(cp_dbcsr_type), INTENT(IN)                    :: matrix_a
      INTEGER, INTENT(IN)                                :: ncol, source_start, target_start
      TYPE(cp_para_env_type), POINTER                    :: para_env
      TYPE(cp_blacs_env_type), POINTER                   :: blacs_env

      CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_dbcsr_copy_columns_hack', &
         routineP = moduleN//':'//routineN

      INTEGER                                            :: nfullcols_total, nfullrows_total
      TYPE(cp_fm_struct_type), POINTER                   :: fm_struct
      TYPE(cp_fm_type), POINTER                          :: fm_matrix_a, fm_matrix_b

      NULLIFY (fm_matrix_a, fm_matrix_b, fm_struct)
      CALL cp_dbcsr_get_info(matrix_a, nfullrows_total=nfullrows_total, nfullcols_total=nfullcols_total)
      CALL cp_fm_struct_create(fm_struct, context=blacs_env, nrow_global=nfullrows_total, &
                               ncol_global=nfullcols_total, para_env=para_env)
      CALL cp_fm_create(fm_matrix_a, fm_struct, name="fm_matrix_a")
      CALL cp_fm_struct_release(fm_struct)

      CALL cp_dbcsr_get_info(matrix_b, nfullrows_total=nfullrows_total, nfullcols_total=nfullcols_total)
      CALL cp_fm_struct_create(fm_struct, context=blacs_env, nrow_global=nfullrows_total, &
                               ncol_global=nfullcols_total, para_env=para_env)
      CALL cp_fm_create(fm_matrix_b, fm_struct, name="fm_matrix_b")
      CALL cp_fm_struct_release(fm_struct)

      CALL copy_dbcsr_to_fm(matrix_a, fm_matrix_a)
      CALL copy_dbcsr_to_fm(matrix_b, fm_matrix_b)

      CALL cp_fm_to_fm(fm_matrix_a, fm_matrix_b, ncol, source_start, target_start)

      CALL copy_fm_to_dbcsr(fm_matrix_b, matrix_b)

      CALL cp_fm_release(fm_matrix_a)
      CALL cp_fm_release(fm_matrix_b)

   END SUBROUTINE cp_dbcsr_copy_columns_hack

! **************************************************************************************************
!> \brief Creates a DBCSR distribution from a distribution_2d
!> \param[in] dist2d          distribution_2d
!> \param[out] dist           DBCSR distribution
!> \param mp_obj ...
!> \par History
!>    move form dbcsr_operation 01.2010
! **************************************************************************************************
   SUBROUTINE cp_dbcsr_dist2d_to_dist(dist2d, dist, mp_obj)
      TYPE(distribution_2d_type), INTENT(IN), TARGET     :: dist2d
      TYPE(dbcsr_distribution_obj), INTENT(OUT)          :: dist
      TYPE(dbcsr_mp_obj), INTENT(IN), OPTIONAL           :: mp_obj

      INTEGER                                            :: mypcol, myproc, myprow, numproc
      INTEGER, DIMENSION(:, :), POINTER                  :: col_dist_data, pgrid, row_dist_data
      TYPE(cp_blacs_env_type), POINTER                   :: blacs_env
      TYPE(cp_para_env_type), POINTER                    :: para_env
      TYPE(dbcsr_mp_obj)                                 :: mp_env
      TYPE(distribution_2d_type), POINTER                :: dist2d_p

!
!   ---------------------------------------------------------------------------

      dist2d_p => dist2d
      CALL distribution_2d_get(dist2d_p, &
                               row_distribution=row_dist_data, col_distribution=col_dist_data, &
                               blacs_env=blacs_env)
      CALL get_blacs_info(blacs_env, para_env=para_env, &
                          my_process_row=myprow, my_process_column=mypcol, &
                          blacs2mpi=pgrid)
      myproc = para_env%mepos
      numproc = para_env%num_pe
      IF (PRESENT(mp_obj)) THEN
         mp_env = mp_obj
         CALL dbcsr_mp_hold(mp_env)
      ELSE
         CALL cp_dbcsr_mp_new(mp_env, pgrid, para_env%group, myproc, numproc, &
                              myprow, mypcol)
      ENDIF
      CALL cp_dbcsr_distribution_new(dist, mp_env, row_dist_data, col_dist_data)
      CALL cp_dbcsr_mp_release(mp_env)
   END SUBROUTINE cp_dbcsr_dist2d_to_dist

! **************************************************************************************************
!> \brief multiply a dbcsr with a replicated array
!>        c = alpha_scalar * A (dbscr) * b + c
!> \param[in] matrix_a DBSCR matrxx
!> \param[in]  vec_b        vectors b
!> \param[inout] vec_c      vectors c
!> \param[in]  ncol         nbr of columns
!> \param[in]  alpha        alpha
!>
! **************************************************************************************************
   SUBROUTINE cp_dbcsr_multiply_local(matrix_a, vec_b, vec_c, ncol, alpha)
      TYPE(cp_dbcsr_type), INTENT(IN)                    :: matrix_a
      REAL(dp), DIMENSION(:, :), INTENT(IN)              :: vec_b
      REAL(dp), DIMENSION(:, :), INTENT(INOUT)           :: vec_c
      INTEGER, INTENT(in), OPTIONAL                      :: ncol
      REAL(dp), INTENT(IN), OPTIONAL                     :: alpha

      CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_dbcsr_multiply_local', &
         routineP = moduleN//':'//routineN

      INTEGER                                            :: blk, col, coloff, my_ncol, row, rowoff, &
                                                            timing_handle
      LOGICAL                                            :: has_symm
      REAL(dp)                                           :: my_alpha, my_alpha2
      REAL(dp), DIMENSION(:, :), POINTER                 :: data_d
      TYPE(cp_dbcsr_iterator)                            :: iter

      CALL timeset(routineN, timing_handle)

      my_alpha = 1.0_dp
      IF (PRESENT(alpha)) my_alpha = alpha

      my_ncol = SIZE(vec_b, 2)
      IF (PRESENT(ncol)) my_ncol = ncol

      my_alpha2 = 0.0_dp
      IF (cp_dbcsr_get_matrix_type(matrix_a) .EQ. dbcsr_type_symmetric) my_alpha2 = my_alpha
      IF (cp_dbcsr_get_matrix_type(matrix_a) .EQ. dbcsr_type_antisymmetric) my_alpha2 = -my_alpha

      has_symm = (cp_dbcsr_get_matrix_type(matrix_a) .EQ. dbcsr_type_symmetric .OR. &
                  cp_dbcsr_get_matrix_type(matrix_a) .EQ. dbcsr_type_antisymmetric)

!$OMP     PARALLEL DEFAULT(NONE) SHARED(matrix_a,vec_b,vec_c,ncol,my_alpha2,my_alpha,my_ncol,has_symm) &
!$OMP              PRIVATE(iter,row,col,data_d,blk,rowoff,coloff)
      CALL cp_dbcsr_iterator_start(iter, matrix_a, read_only=.TRUE., dynamic=.TRUE., dynamic_byrows=.TRUE.)
      DO WHILE (cp_dbcsr_iterator_blocks_left(iter))
         CALL cp_dbcsr_iterator_next_block(iter, row, col, data_d, blk, row_offset=rowoff, col_offset=coloff)
         IF (my_ncol .NE. 1) THEN
            CALL dgemm('N', 'N', &
                       SIZE(data_d, 1), my_ncol, SIZE(data_d, 2), &
                       my_alpha, data_d(1, 1), SIZE(data_d, 1), &
                       vec_b(coloff, 1), SIZE(vec_b, 1), &
                       1.0_dp, vec_c(rowoff, 1), SIZE(vec_c, 1))
         ELSE
            CALL dgemv('N', SIZE(data_d, 1), SIZE(data_d, 2), &
                       my_alpha, data_d(1, 1), SIZE(data_d, 1), &
                       vec_b(coloff, 1), 1, &
                       1.0_dp, vec_c(rowoff, 1), 1)
         ENDIF
      ENDDO
      CALL cp_dbcsr_iterator_stop(iter)
!$OMP     END PARALLEL

      ! FIXME ... in the symmetric case, the writes to vec_c depend on the column, not the row. This makes OMP-ing more difficult
      ! needs e.g. a buffer for vec_c and a reduction of that buffer.
      IF (has_symm) THEN
         CALL cp_dbcsr_iterator_start(iter, matrix_a)
         DO WHILE (cp_dbcsr_iterator_blocks_left(iter))
            CALL cp_dbcsr_iterator_next_block(iter, row, col, data_d, blk, row_offset=rowoff, col_offset=coloff)
            IF (row .NE. col) THEN
               IF (my_ncol .NE. 1) THEN
                  CALL dgemm('T', 'N', &
                             SIZE(data_d, 2), my_ncol, SIZE(data_d, 1), &
                             my_alpha2, data_d(1, 1), SIZE(data_d, 1), &
                             vec_b(rowoff, 1), SIZE(vec_b, 1), &
                             1.0_dp, vec_c(coloff, 1), SIZE(vec_c, 1))
               ELSE
                  CALL dgemv('T', SIZE(data_d, 1), SIZE(data_d, 2), &
                             my_alpha2, data_d(1, 1), SIZE(data_d, 1), &
                             vec_b(rowoff, 1), 1, &
                             1.0_dp, vec_c(coloff, 1), 1)
               ENDIF
            ENDIF
         ENDDO
         CALL cp_dbcsr_iterator_stop(iter)
      ENDIF

      CALL timestop(timing_handle)
   END SUBROUTINE cp_dbcsr_multiply_local


! **************************************************************************************************
!> \brief multiply a dbcsr with a fm matrix
!>
!> For backwards compatibility with BLAS XGEMM, this routine supports
!> the multiplication of matrices with incompatible dimensions.
!>
!> \param[in]  matrix         DBCSR matrix
!> \param fm_in full matrix
!> \param fm_out full matrix
!> \param[in]  ncol           nbr of columns
!> \param[in]  alpha          alpha
!> \param[in]  beta           beta
!>
! **************************************************************************************************
   SUBROUTINE cp_dbcsr_sm_fm_multiply(matrix, fm_in, fm_out, ncol, alpha, beta)
      TYPE(cp_dbcsr_type), INTENT(IN)                    :: matrix
      TYPE(cp_fm_type), POINTER                          :: fm_in, fm_out
      INTEGER, INTENT(IN)                                :: ncol
      REAL(dp), INTENT(IN), OPTIONAL                     :: alpha, beta

      CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_dbcsr_sm_fm_multiply', &
         routineP = moduleN//':'//routineN

      INTEGER                                            :: k_in, k_out, timing_handle, &
                                                            timing_handle_mult
      INTEGER, DIMENSION(:), POINTER                     :: col_blk_size_right_in, &
                                                            col_blk_size_right_out
      TYPE(cp_dbcsr_type)                                :: in, out
      REAL(dp)                                           :: my_alpha, my_beta
      TYPE(dbcsr_distribution_obj)                       :: dist_right_in, product_dist

      CALL timeset(routineN, timing_handle)

      my_alpha = 1.0_dp
      my_beta = 0.0_dp
      IF (PRESENT(alpha)) my_alpha = alpha
      IF (PRESENT(beta)) my_beta = beta

      CALL cp_fm_get_info(fm_out, ncol_global=k_out)

      CALL cp_fm_get_info(fm_in, ncol_global=k_in)
      !write(*,*)routineN//" -----------------------------------"
      !IF (k_in .NE. k_out) &
      !   WRITE(*,'(3(A,I5,1X),2(A,F5.2,1X))')&
      !   routineN//" ncol", ncol,'k_in',k_in,'k_out',k_out,&
      !   'alpha',my_alpha,'beta',my_beta

      IF (ncol .GT. 0 .AND. k_out .GT. 0 .AND. k_in .GT. 0) THEN
         CALL dbcsr_create_dist_r_unrot(dist_right_in, cp_dbcsr_distribution(matrix), k_in, &
                                        col_blk_size_right_in)

         CALL cp_dbcsr_init(in)
         CALL cp_dbcsr_create(in, "D", dist_right_in, dbcsr_type_no_symmetry, &
                              cp_dbcsr_row_block_sizes(matrix), col_blk_size_right_in, &
                              nze=0)

         CALL cp_dbcsr_init(out)
         CALL cp_dbcsr_distribution_new(product_dist, &
                                        dbcsr_distribution_mp(cp_dbcsr_distribution(matrix)), &
                                        dbcsr_distribution_row_dist(cp_dbcsr_distribution(matrix)), &
                                        dbcsr_distribution_col_dist(dist_right_in), &
                                        dbcsr_distribution_row_clusters(cp_dbcsr_distribution(matrix)), &
                                        dbcsr_distribution_col_clusters(dist_right_in))
         ALLOCATE (col_blk_size_right_out(SIZE(col_blk_size_right_in)))
         col_blk_size_right_out = col_blk_size_right_in
         CALL match_col_sizes(col_blk_size_right_out, col_blk_size_right_in, k_out)

         !if (k_in .ne. k_out) then
         !   write(*,*)routineN//" in cs", col_blk_size_right_in
         !   write(*,*)routineN//" out cs", col_blk_size_right_out
         !endif

         CALL cp_dbcsr_create(out, "D", product_dist, dbcsr_type_no_symmetry, &
                              cp_dbcsr_row_block_sizes(matrix), col_blk_size_right_out, &
                              nze=0)

         CALL copy_fm_to_dbcsr(fm_in, in)
         IF (ncol .NE. k_out .OR. my_beta .NE. 0.0_dp) &
            CALL copy_fm_to_dbcsr(fm_out, out)

         CALL timeset(routineN//'_core', timing_handle_mult)
         CALL cp_dbcsr_multiply("N", "N", my_alpha, matrix, in, my_beta, out, &
                                last_column=ncol, match_matrix_sizes=.TRUE.)
         CALL timestop(timing_handle_mult)

         CALL copy_dbcsr_to_fm(out, fm_out)

         CALL cp_dbcsr_release(in)
         CALL cp_dbcsr_release(out)
         DEALLOCATE (col_blk_size_right_in, col_blk_size_right_out)
         CALL dbcsr_distribution_release(dist_right_in)
         CALL dbcsr_distribution_release(product_dist)

      ENDIF

      CALL timestop(timing_handle)

   END SUBROUTINE cp_dbcsr_sm_fm_multiply

! **************************************************************************************************
!> \brief ...
!> \param sizes1 ...
!> \param sizes2 ...
!> \param full_num ...
! **************************************************************************************************
   SUBROUTINE match_col_sizes(sizes1, sizes2, full_num)
      INTEGER, DIMENSION(:), INTENT(INOUT)               :: sizes1
      INTEGER, DIMENSION(:), INTENT(IN)                  :: sizes2
      INTEGER, INTENT(IN)                                :: full_num

      INTEGER                                            :: left, n1, n2, p, rm, used

      n1 = SIZE(sizes1)
      n2 = SIZE(sizes2)
      IF (n1 .NE. n2) &
         CPABORT("distributions must be equal!")
      sizes1(1:n1) = sizes2(1:n1)
      used = SUM(sizes1(1:n1))
      ! If sizes1 does not cover everything, then we increase the
      ! size of the last block; otherwise we reduce the blocks
      ! (from the end) until it is small enough.
      IF (used .LT. full_num) THEN
         sizes1(n1) = sizes1(n1)+full_num-used
      ELSE
         left = used-full_num
         p = n1
         DO WHILE (left .GT. 0 .AND. p .GT. 0)
            rm = MIN(left, sizes1(p))
            sizes1(p) = sizes1(p)-rm
            left = left-rm
            p = p-1
         ENDDO
      ENDIF
   END SUBROUTINE match_col_sizes

! **************************************************************************************************
!> \brief performs the multiplication sparse_matrix+dense_mat*dens_mat^T
!>        if matrix_g is not explicitly given, matrix_v^T will be used
!>        this can be important to save the necessary redistribute for a
!>        different matrix_g and increase performance.
!> \param sparse_matrix ...
!> \param matrix_v ...
!> \param matrix_g ...
!> \param ncol ...
!> \param alpha ...
!> \param keep_sparsity Determines if the sparsity of sparse_matrix is retained
!>        by default it is TRUE
! **************************************************************************************************
   SUBROUTINE cp_dbcsr_plus_fm_fm_t(sparse_matrix, matrix_v, matrix_g, ncol, &
                                           alpha, keep_sparsity)
      TYPE(cp_dbcsr_type), INTENT(INOUT)                 :: sparse_matrix
      TYPE(cp_fm_type), POINTER                          :: matrix_v
      TYPE(cp_fm_type), OPTIONAL, POINTER                :: matrix_g
      INTEGER, INTENT(IN)                                :: ncol
      REAL(KIND=dp), INTENT(IN), OPTIONAL                :: alpha
      LOGICAL, INTENT(IN), OPTIONAL                      :: keep_sparsity

      CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_dbcsr_plus_fm_fm_t_native', &
         routineP = moduleN//':'//routineN

      INTEGER                                            :: k, nao, timing_handle
      INTEGER, DIMENSION(:), POINTER                     :: col_blk_size_left, col_dist_cluster, &
                                                            col_dist_left
      LOGICAL                                            :: check_product, my_keep_sparsity
      REAL(KIND=dp)                                      :: my_alpha, norm
      TYPE(cp_dbcsr_type)                                :: mat_g, mat_v, sparse_matrix2, &
                                                            sparse_matrix3
      TYPE(cp_fm_struct_type), POINTER                   :: fm_struct_tmp
      TYPE(cp_fm_type), POINTER                          :: fm_matrix
      TYPE(dbcsr_distribution_obj)                       :: dist_left
      TYPE(dbcsr_mp_obj)                                 :: mp

      check_product = .FALSE.

      CALL timeset(routineN, timing_handle)

      my_keep_sparsity = .TRUE.
      IF (PRESENT(keep_sparsity)) my_keep_sparsity = keep_sparsity
      NULLIFY (col_dist_left)

      IF (ncol .GT. 0) THEN
         IF (.NOT. cp_dbcsr_valid_index(sparse_matrix)) &
            CPABORT("sparse_matrix must pre-exist")
         !
         ! Setup matrix_v
         CALL cp_fm_get_info(matrix_v, ncol_global=k)
         !WRITE(*,*)routineN//'truncated mult k, ncol',k,ncol,' PRESENT (matrix_g)',PRESENT (matrix_g)
         mp = dbcsr_distribution_mp(cp_dbcsr_distribution(sparse_matrix))
         CALL cp_create_bl_distribution(col_dist_left, col_blk_size_left, &
                                        k, dbcsr_mp_npcols(mp))
         NULLIFY (col_dist_cluster)
         CALL cp_dbcsr_distribution_new(dist_left, mp, &
                                        dbcsr_distribution_row_dist(cp_dbcsr_distribution(sparse_matrix)), &
                                        col_dist_left, &
                                        dbcsr_distribution_row_clusters(cp_dbcsr_distribution(sparse_matrix)), &
                                        col_dist_cluster)
         DEALLOCATE (col_dist_left)
         CALL cp_dbcsr_init(mat_v)
         CALL cp_dbcsr_create(mat_v, "DBCSR matrix_v", dist_left, dbcsr_type_no_symmetry, &
                              cp_dbcsr_row_block_sizes(sparse_matrix), col_blk_size_left, nze=0, &
                              data_type=cp_dbcsr_get_data_type(sparse_matrix))
         CALL copy_fm_to_dbcsr(matrix_v, mat_v)
         CALL cp_dbcsr_verify_matrix(mat_v)
         !
         ! Setup matrix_g
         IF (PRESENT(matrix_g)) THEN
            CALL cp_dbcsr_init(mat_g)
            CALL cp_dbcsr_create(mat_g, "DBCSR matrix_g", dist_left, &
                                 dbcsr_type_no_symmetry, &
                                 cp_dbcsr_row_block_sizes(sparse_matrix), &
                                 cp_dbcsr_col_block_sizes(mat_v), &
                                 data_type=cp_dbcsr_get_data_type(sparse_matrix))
            CALL copy_fm_to_dbcsr(matrix_g, mat_g)
         ENDIF
         !
         DEALLOCATE (col_blk_size_left)
         CALL dbcsr_distribution_release(dist_left)
         !
         !
         IF (check_product) THEN
            NULLIFY (fm_matrix)
            CALL cp_fm_get_info(matrix_v, nrow_global=nao)
            CALL cp_fm_struct_create(fm_struct_tmp, context=matrix_v%matrix_struct%context, nrow_global=nao, &
                                     ncol_global=nao, para_env=matrix_v%matrix_struct%para_env)
            CALL cp_fm_create(fm_matrix, fm_struct_tmp, name="fm matrix")
            CALL cp_fm_struct_release(fm_struct_tmp)
            CALL copy_dbcsr_to_fm(sparse_matrix, fm_matrix)
            CALL cp_dbcsr_init(sparse_matrix3)
            CALL cp_dbcsr_copy(sparse_matrix3, sparse_matrix)
         ENDIF
         !
         my_alpha = 1.0_dp
         IF (PRESENT(alpha)) my_alpha = alpha
         IF (PRESENT(matrix_g)) THEN
            CALL cp_dbcsr_multiply("N", "T", my_alpha, mat_v, mat_g, &
                                   1.0_dp, sparse_matrix, &
                                   retain_sparsity=my_keep_sparsity, &
                                   last_k=ncol)
         ELSE
            CALL cp_dbcsr_multiply("N", "T", my_alpha, mat_v, mat_v, &
                                   1.0_dp, sparse_matrix, &
                                   retain_sparsity=my_keep_sparsity, &
                                   last_k=ncol)
         ENDIF

         IF (check_product) THEN
            IF (PRESENT(matrix_g)) THEN
               CALL cp_fm_gemm("N", "T", nao, nao, ncol, my_alpha, matrix_v, matrix_g, &
                               1.0_dp, fm_matrix)
            ELSE
               CALL cp_fm_gemm("N", "T", nao, nao, ncol, my_alpha, matrix_v, matrix_v, &
                               1.0_dp, fm_matrix)
            ENDIF

            CALL cp_dbcsr_init(sparse_matrix2)
            CALL cp_dbcsr_copy(sparse_matrix2, sparse_matrix)
            CALL cp_dbcsr_scale(sparse_matrix2, alpha_scalar=0.0_dp)
            CALL copy_fm_to_dbcsr(fm_matrix, sparse_matrix2, keep_sparsity=my_keep_sparsity)
            CALL cp_dbcsr_add(sparse_matrix2, sparse_matrix, alpha_scalar=1.0_dp, &
                              beta_scalar=-1.0_dp)
            CALL cp_dbcsr_norm(sparse_matrix2, which_norm=dbcsr_norm_frobenius, &
                               norm_scalar=norm)
            WRITE (*, *) 'nao=', nao, ' k=', k, ' ncol=', ncol, ' my_alpha=', my_alpha
            WRITE (*, *) 'PRESENT (matrix_g)', PRESENT(matrix_g)
            WRITE (*, *) 'matrix_type=', cp_dbcsr_get_matrix_type(sparse_matrix)
            WRITE (*, *) 'norm(sm+alpha*v*g^t - fm+alpha*v*g^t)/n=', norm/REAL(nao, dp)
            IF (norm/REAL(nao, dp) .GT. 1e-12_dp) THEN
               !WRITE(*,*) 'fm_matrix'
               !DO j=1,SIZE(fm_matrix%local_data,2)
               !   DO i=1,SIZE(fm_matrix%local_data,1)
               !      WRITE(*,'(A,I3,A,I3,A,E26.16,A)') 'a(',i,',',j,')=',fm_matrix%local_data(i,j),';'
               !   ENDDO
               !ENDDO
               !WRITE(*,*) 'mat_v'
               !CALL cp_dbcsr_print(mat_v,matlab_format=.TRUE.)
               !WRITE(*,*) 'mat_g'
               !CALL cp_dbcsr_print(mat_g,matlab_format=.TRUE.)
               !WRITE(*,*) 'sparse_matrix'
               !CALL cp_dbcsr_print(sparse_matrix,matlab_format=.TRUE.)
               !WRITE(*,*) 'sparse_matrix2 (-sm + sparse(fm))'
               !CALL cp_dbcsr_print(sparse_matrix2,matlab_format=.TRUE.)
               !WRITE(*,*) 'sparse_matrix3 (copy of sm input)'
               !CALL cp_dbcsr_print(sparse_matrix3,matlab_format=.TRUE.)
               !stop
            ENDIF
            CALL cp_dbcsr_release(sparse_matrix2)
            CALL cp_dbcsr_release(sparse_matrix3)
            CALL cp_fm_release(fm_matrix)
         ENDIF
         CALL cp_dbcsr_release(mat_v)
         IF (PRESENT(matrix_g)) CALL cp_dbcsr_release(mat_g)
      ENDIF
      CALL timestop(timing_handle)

   END SUBROUTINE cp_dbcsr_plus_fm_fm_t

! **************************************************************************************************
!> \brief Utility function to copy a specially shaped fm to dbcsr_matrix
!>        The result matrix will be the matrix in dbcsr format
!>        with the row blocks sizes according to the block_sizes of the template
!>        and the col blocks sizes evenly blocked with the internal dbcsr conversion
!>        size (32 is the current default)
!> \param matrix ...
!> \param fm_in ...
!> \param template ...
! **************************************************************************************************
   SUBROUTINE cp_fm_to_dbcsr_row_template(matrix, fm_in, template)
      TYPE(cp_dbcsr_type), INTENT(INOUT)                 :: matrix
      TYPE(cp_fm_type), POINTER                          :: fm_in
      TYPE(cp_dbcsr_type), INTENT(IN)                    :: template

      CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_fm_to_dbcsr_row_template', &
         routineP = moduleN//':'//routineN

      INTEGER                                            :: k_in
      INTEGER, DIMENSION(:), POINTER                     :: col_blk_size_right_in
      TYPE(dbcsr_distribution_obj)                       :: dist_right_in

      CALL cp_fm_get_info(fm_in, ncol_global=k_in)

      CALL dbcsr_create_dist_r_unrot(dist_right_in, cp_dbcsr_distribution(template), k_in, &
                                     col_blk_size_right_in)
      CALL cp_dbcsr_init(matrix)
      CALL cp_dbcsr_create(matrix, "D", dist_right_in, dbcsr_type_no_symmetry, &
                           cp_dbcsr_row_block_sizes(template), col_blk_size_right_in, &
                           nze=0, data_type=cp_dbcsr_get_data_type(template))

      CALL copy_fm_to_dbcsr(fm_in, matrix)
      DEALLOCATE (col_blk_size_right_in)
      CALL dbcsr_distribution_release(dist_right_in)

   END SUBROUTINE cp_fm_to_dbcsr_row_template

! **************************************************************************************************
!> \brief Utility function to create an arbitrary shaped dbcsr matrix
!>        with the same processor grid as the template matrix
!>        both row sizes and col sizes are evenly blocked with the internal
!>        dbcsr_conversion size (32 is the current default)
!> \param matrix dbcsr matrix to be created
!> \param template template dbcsr matrix giving its mp_env
!> \param m global row size of output matrix
!> \param n global col size of output matrix
!> \param sym ...
!> \param data_type ...
! **************************************************************************************************
   SUBROUTINE cp_dbcsr_m_by_n_from_template(matrix, template, m, n, sym, data_type)
      TYPE(cp_dbcsr_type), INTENT(INOUT)                 :: matrix, template
      INTEGER                                            :: m, n
      CHARACTER, OPTIONAL                                :: sym
      INTEGER, OPTIONAL                                  :: data_type

      CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_dbcsr_m_by_n_from_template', &
         routineP = moduleN//':'//routineN

      CHARACTER                                          :: mysym
      INTEGER                                            :: my_data_type
      INTEGER, DIMENSION(:), POINTER                     :: col_blk_size, col_cluster_dist, &
                                                            col_dist, row_blk_size, &
                                                            row_cluster_dist, row_dist
      TYPE(dbcsr_distribution_obj)                       :: dist_m_n

      mysym = cp_dbcsr_get_matrix_type(template)
      IF (PRESENT(sym)) mysym = sym
      my_data_type = cp_dbcsr_get_data_type(template)
      IF (PRESENT(data_type)) my_data_type = data_type

      NULLIFY (row_dist, col_dist)
      NULLIFY (row_blk_size, col_blk_size)
      NULLIFY (row_cluster_dist, col_cluster_dist)

      CALL cp_create_bl_distribution(row_dist, row_blk_size, m, &
                                     dbcsr_mp_nprows(dbcsr_distribution_mp(cp_dbcsr_distribution(template))))
      CALL cp_create_bl_distribution(col_dist, col_blk_size, n, &
                                     dbcsr_mp_npcols(dbcsr_distribution_mp(cp_dbcsr_distribution(template))))
      CALL cp_dbcsr_distribution_new(dist_m_n, dbcsr_distribution_mp(cp_dbcsr_distribution(template)), &
                                     row_dist, col_dist, &
                                     row_cluster_dist, col_cluster_dist, &
                                     reuse_arrays=.TRUE.)

      CALL cp_dbcsr_create(matrix, "m_n_template", dist_m_n, mysym, &
                           row_blk_size, col_blk_size, nze=0, data_type=my_data_type, &
                           reuse_arrays=.TRUE.)
      CALL dbcsr_distribution_release(dist_m_n)

   END SUBROUTINE cp_dbcsr_m_by_n_from_template

! **************************************************************************************************
!> \brief Utility function to create dbcsr matrix, m x n matrix (n arbitrary)
!>        with the same processor grid and row distribution  as the template matrix
!>        col sizes are evenly blocked with the internal
!>        dbcsr_conversion size (32 is the current default)
!> \param matrix dbcsr matrix to be created
!> \param template template dbcsr matrix giving its mp_env
!> \param n global col size of output matrix
!> \param sym ...
!> \param data_type ...
! **************************************************************************************************
   SUBROUTINE cp_dbcsr_m_by_n_from_row_template(matrix, template, n, sym, data_type)
      TYPE(cp_dbcsr_type), INTENT(INOUT)                 :: matrix, template
      INTEGER                                            :: n
      CHARACTER, OPTIONAL                                :: sym
      INTEGER, OPTIONAL                                  :: data_type

      CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_dbcsr_m_by_n_from_row_template', &
         routineP = moduleN//':'//routineN

      CHARACTER                                          :: mysym
      INTEGER                                            :: my_data_type
      INTEGER, DIMENSION(:), POINTER                     :: col_blk_size, col_cluster_dist, col_dist
      TYPE(dbcsr_distribution_obj)                       :: dist_m_n

      mysym = cp_dbcsr_get_matrix_type(template)
      IF (PRESENT(sym)) mysym = sym
      my_data_type = cp_dbcsr_get_data_type(template)
      IF (PRESENT(data_type)) my_data_type = data_type

      NULLIFY (col_dist, col_blk_size)

      CALL cp_create_bl_distribution(col_dist, col_blk_size, n, &
                                     dbcsr_mp_npcols(dbcsr_distribution_mp(cp_dbcsr_distribution(template))))
      NULLIFY (col_cluster_dist)
      CALL cp_dbcsr_distribution_new(dist_m_n, dbcsr_distribution_mp(cp_dbcsr_distribution(template)), &
                                     dbcsr_distribution_row_dist(cp_dbcsr_distribution(template)), col_dist, &
                                     dbcsr_distribution_row_clusters(cp_dbcsr_distribution(template)), &
                                     col_cluster_dist)

      CALL cp_dbcsr_create(matrix, "m_n_template", dist_m_n, mysym, &
                           cp_dbcsr_row_block_sizes(template), col_blk_size, nze=0, data_type=my_data_type)

      DEALLOCATE (col_dist, col_blk_size)
      CALL dbcsr_distribution_release(dist_m_n)

   END SUBROUTINE cp_dbcsr_m_by_n_from_row_template

END MODULE cp_dbcsr_operations
